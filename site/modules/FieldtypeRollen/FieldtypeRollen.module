<?php namespace ProcessWire;

/**
 * Ein Feld, das Rollen speichert - in Kombination mit Besetzungen.
 */

class FieldtypeRollen extends FieldtypeMulti {

	public static function getModuleInfo() {
		return array(
			'title' => 'Rollen',
			'version' => '0.1.0',
			'summary' => 'Ein Feld, das Rollen speichert - in Kombination mit Besetzungen.',
			'installs' => 'InputfieldRollen',
			);
	}

	public function __construct() {
		require_once(dirname(__FILE__) . '/Rolle.class.php');
		require_once(dirname(__FILE__) . '/RollenArray.class.php');

		parent::__construct();
	}

	public function getProjektseite(){
		$seite = wire('pages')->get($this->input->get->id);
		if(!$seite->id) $seite = wire('pages')->get('/');
		$projektseite = $seite->closest("template.name=projekt|home");
		return $projektseite;
	}

	public function getRollen(){
		$container = $this->getProjektseite()->find('template.name=rollen_container, include=hidden');
		$seiten = new PageArray();
		if($container instanceof PageArray && count($container) > 0){
			foreach($container as $seite){
				$seiten->add($seite->children('template.name=rolle, include=hidden'));
			}
		}
		return $seiten;
	}

	public function getBesetzungen(){
		$container = $this->getProjektseite()->find('template.name=besetzungen_container, include=hidden');
		$seiten = new PageArray();
		if($container instanceof PageArray && count($container) > 0){
			foreach($container as $seite){
				$seiten->add($seite->children('template.name=besetzung'));
			}
		}
		return $seiten;
	}

	/**
	 * Return the required Inputfield used to populate a field of this type
	 *
	 */
	public function getInputfield(Page $seite, Field $feld) {
		$inputfield = $this->modules->get("InputfieldRollen");

		$inputfield->setRollen($this->getRollen());
		$inputfield->setBesetzungen($this->getBesetzungen());

		return $inputfield;
	}

	public function ___getCompatibleFieldtypes(Field $feld) {
		// there are no other fieldtypes compatible with this one
		return null;
	}

	/**
	 * Given a value, make it clean for storage within a Page
	 *
	 */
	public function sanitizeValue(Page $page, Field $feld, $value) {
		// if given a blank value, return a valid blank value
		if(empty($value) || !$value instanceof RollenArray) return $this->getBlankValue($page, $feld, $value);
		if($value->isChanged('rollen')) $page->trackChange($feld->name);
		return $value;
	}

	/**
	 * Return a blank ready-to-populate version of a field of this type
	 *
	 */
	public function getBlankValue(Page $page, Field $feld) {
		$rollen = new RollenArray();
		$rollen->setTrackChanges(true);
		return $rollen;
	}


	/**
	* Given a raw value (value as stored in DB), return the value as it would appear in a Page object
	*
	* @param Page $page
	* @param Field $feld
	* @param string|int|array $value
	* @return string|int|array|object $value
	*
	*/
	public function ___wakeupValue(Page $page, Field $feld, $value) {

		// if for some reason we already get a valid value, then just return it
		if($value instanceof RollenArray) return $value;

		// start a blank value to be populated
		$rollen = $this->getBlankValue($page, $feld);

		// if we were given a blank value, then we've got nothing to do: just return a blank EventArray
		if(empty($value) || !is_array($value)) return $rollen;

		// create new Rolle objects from each item in the array
		foreach($value as $v) {
			$rolle = new Rolle($v['data']);
			$rolle->besetzungen = $v['besetzungen'];
			$rolle->setTrackChanges(true);
			$rollen->add($rolle);
		}

		$rollen->resetTrackChanges();

		return $rollen;
	}

	/**
	 * Given an 'awake' value, as set by wakeupValue, convert the value back to a basic type for storage in DB.
	 *
	 * @param Page $page
	 * @param Field $field
	 * @param string|int|array|object $value
	 * @return string|int
	 *
	 */
	public function ___sleepValue(Page $page, Field $field, $value) {

		$sleepValue = array();

		// if we are given something other than an RollenArray,
		// then just return a blank array
		if(!$value instanceof RollenArray) return $sleepValue;

		// $value->sort('sort');

		// convert each Rolle to an array within sleepValue
		foreach($value as $rolle) {
			$besetzungen = array();
			foreach($rolle->besetzungen as $besetzung){
				if(!$besetzung instanceof Page || !$besetzung->id) continue;
				$besetzungen[] = $besetzung->id;
			}

			$sleepValue[] = array(
				'data' => $rolle->rolle->id, // note: rolle is becoming data
				'besetzungen' => json_encode($besetzungen)
				);
		}
		return $sleepValue;
	}

	/**
	 * Format a value for output, called when a Page's outputFormatting is on
	 *
	 */
	public function formatValue(Page $page, Field $feld, $value) {
		// we actually don't need to do anything in here since each Rolle object
		// is doing this work in the Rolle::get() method. But I've included this
		// comment here just to explain where that is taking place.
		return $value;
	}

	/**
	 * Return the database schema that defines an Rolle
	 *
	 */
	public function getDatabaseSchema(Field $field) {
		$schema = parent::getDatabaseSchema($field);

		// 'data' is a required field for any Fieldtype, and we're using it to represent our 'date' field
		$schema['data'] = 'INT NOT NULL DEFAULT 0';

		// our text fields
		$schema['besetzungen'] = 'TEXT';

		// indexes, for any fields that need to be searchable from selectors
		// in this case, we're just making our 'rolle' field searchable
		// but the others could easily be added, likely as fulltext indexes
		$schema['keys']['data'] = 'KEY data(data)';

		return $schema;
	}

	/**
	 * Method called when the field is database-queried from a selector
	 *
	 */
	public function getMatchQuery($query, $table, $subfield, $operator, $value) {
		// If searching 'rolle' then assume our default (data) field
		if($subfield == 'rolle') $subfield = 'data';

		// if value is a formatted date, convert it to unix timestamp
		if(!ctype_digit("$value")) $value = strtotime($value);

		return parent::getMatchQuery($query, $table, $subfield, $operator, $value);
	}

}

